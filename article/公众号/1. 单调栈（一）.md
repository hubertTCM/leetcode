开头不晓得写什么，就直接看题目吧。

1.  柱状图中最大的矩形（84） // 括号内数字表示leetcode中的题号，下同。  
    - 题目  
        给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为1。
        求在该柱状图中，能够勾勒出来的矩形的最大面积。

        示例 1:  
        ![](1-1.jpeg)   
        输入：heights = [2,1,5,6,2,3]  
        输出：10  
        解释：最大的矩形为图中红色区域，面积为 10  

        示例 2：  
        ![](1-2.jpeg)  
        输入： heights = [2,4]  
        输出： 4  
    - 解答  
        数组$heights[i...j]$，假设最小值是$m_{i, j}$对应的矩形面积是$m_{i, j}*(j-i+1)$。因此$O(n^2)$的算法是比较好想到的，我们只要穷举所有的子数组，得到最其中的最小值，就可以求得面积。在所有的面积中，取最大的那个，就是答案了。  
        其实，利用单调栈，只扫描一遍数组就可以求得最大值，时间复杂度$O(n)$。我们维持一个栈(S)，保证从栈底到栈顶单调上升。下面是详细过程：
        从左到右扫描数组，对于每个下标$i$
        1. 如果栈为空，将$i$入栈。否则需要比较当前元素和栈顶元素大小
        2. 如果$heights[S.top]<heights[i]$，则入栈
        3. 否则，弹出栈顶元素，直至栈为空或者$heights[S.top]<heights[i]$，将$i$入栈  

        根据算法步骤，对于每个出栈的元素$S.top$，假设在单调栈下一个元素是$x$，我们知道$heights[x]$是左边第一个比$heights[S.top]$小的元素，$heights[i]$是右边第一个比$heights[S.top]$小的元素。按道理，这里应该以`示例1`为例，放一个动画，显示单调栈的构造过程，并且对于$heights$数组中每个元素，显示该元素左边与右边第一个比它小的元素位置。但是，我做动画不太熟练，所以就没有做.... 如果有兴趣，你们可以自己做做这个动画，或者在纸上画画吧。:)

        还是用数学语言做个简短的说明吧。假设$heights[i]$，左边第一个比它小的数字是$heights[left]$，右边第一个比它小的是$heights[right]$。可以用反证法证明，$i$入栈的时候，$left$一定在$i$下面，$right$入栈的时候，$i$一定在$right$下面。  
        假设$i$的下面不是$left$，而是$x$，那么根据$3$，我们知道$x<i且heights[x]<heights[i]$。又根据$heights[i]$左边第一个比它小的数字是$heights[left]$，我们知道$x<left$。那么根据我们构造单调栈的规则，$x$要么已经被$left$弹出，要么在$left$下面。所以$x$不可能直接在$i$的下面。同理，$right$入栈的时候，$i$一定在$right$下面。

        同样，按照这个算法构造从栈底到栈顶单调减小的单调栈，就可以非常容易求出左右两边第一个比自己大的元素。

    - 代码
        ```C#
        public int LargestRectangleArea(int[] heights)
        {
            var stack = new Stack<int>();
            var ans = 0;
            for (var i = 0; i < heights.Length; i++)
            {
                while (stack.Count > 0 && heights[stack.Peek()] >= heights[i])
                {
                    var temp = stack.Pop();
                    var h = heights[temp];
                    var leftMostIndex = stack.Count == 0 ? 0 : (stack.Peek() + 1);
                    var rightMostIndex = i - 1;
                    // heights[temp]是数组[leftMostIndex, rightMostIndex]中的最小值
                    var w = rightMostIndex - leftMostIndex + 1;
                    ans = Math.Max(ans, w * h);
                }
                stack.Push(i);
            }
            while (stack.Count > 0)
            {
                var h = heights[stack.Pop()];
                var leftMostIndex = stack.Count == 0 ? 0 : (stack.Peek() + 1);
                var rightMostIndex = heights.Length - 1;
                var w = rightMostIndex - leftMostIndex + 1;
                ans = Math.Max(ans, w * h);
            }
            return ans;
        }
        ``` 
1.  去除重复字母（316）  
    给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证返回结果的字典序最小（要求不能打乱其他字符的相对位置）。
    - 提示：给定一个字符串$s$，找出最小的满足 $s[i]>s[i+1]$ 的下标$i$，并去除字符$s[i]$，得到的字符串字典序最小。可以利用一个单调栈来找到所有这样的$i$

1. 移掉 K 位数字（402）  
    给你一个以字符串表示的非负整数 num 和一个整数 k ，移除这个数中的 k 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。
    - 提示：同316

1. 下一个更大元素I(496)  
    给你两个没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。nums1 中数字 x 的下一个更大元素是指 x在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1
    - 提示：标准的单调栈的应用，只是需要用一个哈希表把结果存好。 

1. 每日温度（739）  
    请根据每日 气温 列表 temperatures ，请计算在每一天需要等几天才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。

1. 股票价格跨度（901）  
    编写一个 StockSpanner 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。例如，如果未来7天股票的价格是 [100, 80, 60, 70, 60, 75, 85]，那么股票跨度将是 [1, 1, 1, 2, 1, 4, 6]。
    - 提示：单调栈里面不仅需要保存位置，还需要保存这个位置对应元素的值。

1. 子数组的最小值之和 (907)  
    给定一个整数数组 arr，找到 min(b) 的总和，其中 b 的范围为 arr 的每个（连续）子数组。由于答案可能很大，因此 返回答案模 10^9 + 7 。
    - 提示：对于每个位置$k$，可以求出以$A[K]$为最小值的最长数组，不妨设该数组的左右边界分别是$i,j$，这以$A[K]$为最小值的数组个数有$(k-i+1)*(j-k+1)$个。因为每个子数组必须包含$k$，因为该数组左边界有只能选$i, i+1 ... k$，右边界只能选$k, k+1, .... j$

应该还有一些题目可以直接用单调栈做的，我就不一一列出了。毕竟复制粘贴题目也还是很辛苦的。